SyntaxError: not a TIFF file (header b"b'Exif\\x" not valid)  的解决方法
https://github.com/AUTOMATIC1111/stable-diffusion-webui/issues/11126
https://github.com/Mikubill/sd-webui-controlnet/issues/1559
图片信息错误--将图片截图在转化就不会有问题



安装gfpgan报错（安装时候解决）：
RuntimeError: Couldn't install gfpgan.
ERROR: Could not find a version that satisfies the requirement cython
安装cython即可
pip install cython==0.29.36


----解决阿里云函数无法用ssl下载模型的问题(重要---重启云函数才会生效---)------
修改源码 vi /mnt/sdwebui_public/versions/sdwebui_env/miniconda3/envs/sd_python310/lib/python3.10/urllib/request.py
重现错误代码
###############
import urllib.request
url = 'https://github.com/xinntao/Real-ESRGAN/releases/download/v0.1.0/RealESRGAN_x4plus.pth'
urllib.request.urlretrieve(url, 'yxtestexample.pth')
############### 下面是修改的地方，在文件开始位置111行左右
try:
    import ssl
    # modify by yx --disabled ssl
    ssl._create_default_https_context = ssl._create_unverified_context
    print("yx--modify-ssl--")
    # end --- modify by yx
except ImportError:
    _have_ssl = False
else:
    _have_ssl = True
###############



vi extensions/sd-webui-additional-networks/scripts/model_util.py
修改164行的函数为下面的(这个可以检查lora是否完整---原来的功能是不完整则不启动sd, 我改为了打印出来不完整的lora文件名，但还是启动sd，不将错误的lora显示在下拉列表):
解决报错: 
[AddNet] Updating model hashes... 
Error loading script: model_util.py
RuntimeError: self.size(-1) must be divisible by 4 to view Byte as Float (different element sizes), but got 689998
####################
def hash_model_file(finfo):
    filename = finfo[0]
    stat = finfo[1]
    name = os.path.splitext(os.path.basename(filename))[0]

    # Prevent a hypothetical "None.pt" from being listed.
    if name != "None":
        metadata = None

        cached = cache("hashes").get(filename, None)
        if cached is None or stat.st_mtime != cached["mtime"]:
            if metadata is None and model_util.is_safetensors(filename):
                try:
                    metadata = safetensors_hack.read_metadata(filename)
                except Exception as ex:
                    return {"error": ex, "filename": filename}
            model_hash = get_model_hash(metadata, filename)
            # modify by yx
            # legacy_hash = get_legacy_hash(metadata, filename)
            try:
                legacy_hash = get_legacy_hash(metadata, filename)
            except Exception as ex:
                print(111111, 'yx print----', filename)
                return {"error": ex, "filename": filename}
            # end-modify by yx
        else:
            model_hash = cached["model"]
            legacy_hash = cached["legacy"]

    return {"model": model_hash, "legacy": legacy_hash, "fileinfo": finfo}
####################


解决gradio使用queue前端无限等待的情况, 等待秒数无限增长 （做保活的时候发现的）
参考: https://github.com/gradio-app/gradio/issues/3794
修改代码/Users/yuanxiao/.pyenv/versions/3.11.1/envs/py3.11_virtualenv_test/lib/python3.11/site-packages/gradio/routes.py
服务器在: /mnt/sdwebui_public/versions/sdwebui_env/miniconda3/envs/sd_python310/lib/python3.10/site-packages/gradio/routes.py
join_queue这个方法
#####
            if 0: # modify by yx
                # 原来的代码--3.23.0是设置的timout=1,容易在海外出现这个bug（sdwebui用的这个版本）; 本地的3.32.0已经默认是timeout=5了
                try:
                    session_info = await asyncio.wait_for(
                        websocket.receive_json(), timeout=5  # timeout设置成0.0001本地必现无限等待这个bug
                    )
                except AsyncTimeOutError:
                    return
            else:
                # modify by yx
                retry_receive_count = 3
                for i in range(retry_receive_count):
                    try:
                        session_info = await asyncio.wait_for(
                            websocket.receive_json(), timeout=5
                        )
                        break
                    except AsyncTimeOutError:
                        if i == retry_receive_count - 1: 
                            raise HTTPException("no data") # 这里不要return，否则会出现前端无限等待的情况，抛出错误可以让前端继续执行
                            break
                        else:
                            await asyncio.sleep(1)
                            continue
#####



插件posex不起作用 （需要降低gradio的版本，很麻烦，不安装这个插件了）-----新版本的sdwebui，目前只有等作者修复------
https://github.com/hnmr293/posex/issues/39
事实上，posex 由于新版本的 gradio（3.31）而崩溃，而旧的 canvas-zoom 在 gradio 版本（3.28.1）上工作。所以安装旧版本后，posex就起作用了。



下面的错误在sdwebui打开web页面时候，在浏览器f12的console中出现，但是不影响使用
/openpose_editor_index openpose_editor.js 404 notfound
是sd-webui-controlnet这个插件爆出来的，但是好像没有什么影响



修改styles的提示词保存的时候，需要修改源码
/Users/yuanxiao/workspace/0yxgithub/stable-diffusion-webui/modules/styles.py
修改save_styles这个方法:
########################################################################
def save_styles(self, path: str) -> None:
    # Always keep a backup file around
    if os.path.exists(path):
        shutil.copy(path, f"{path}.bak")

    fd = os.open(path, os.O_RDWR|os.O_CREAT)
    with os.fdopen(fd, "w", encoding="utf-8-sig", newline='') as file:
        # _fields is actually part of the public API: typing.NamedTuple is a replacement for collections.NamedTuple,
        # and collections.NamedTuple has explicit documentation for accessing _fields. Same goes for _asdict()
        writer = csv.DictWriter(file, fieldnames=PromptStyle._fields)
        writer.writeheader()
        writer.writerows(style._asdict() for k,     style in self.styles.items())
########################################################################
修改为下面的代码---支持软连接的代码
########################################################################
def save_styles(self, path: str) -> None:
    def copy_file(path):
        target_path = os.path.realpath(path)
        shutil.copy(target_path, f"{target_path}.bak")
    
    if os.path.islink(path):
        copy_file(path)
        realpath = os.path.realpath(path)
    elif os.path.exists(path):
        shutil.copy(path, f"{path}.bak")
        realpath = path
    
    path = realpath
    fd = os.open(path, os.O_RDWR|os.O_CREAT)
    with os.fdopen(fd, "w", encoding="utf-8-sig", newline='') as file:
        # _fields is actually part of the public API: typing.NamedTuple is a replacement for collections.NamedTuple,
        # and collections.NamedTuple has explicit documentation for accessing _fields. Same goes for _asdict()
        writer = csv.DictWriter(file, fieldnames=PromptStyle._fields)
        writer.writeheader()
        writer.writerows(style._asdict() for k,     style in self.styles.items())
    
########################################################################






如果要修改styles的提示词搜索调用api，保存需要修改这里（todo---可选）：
/Users/yuanxiao/workspace/0yxgithub/stable-diffusion-webui/modules/ui.py
搜索: ask_for_style_name
搜索: apply_styles, add_style